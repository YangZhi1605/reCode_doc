分析

 这段代码的主要功能是读取天线范围内的RFID卡片的卡号，并在屏幕上进行显示。

```
//通过刷卡模块检测
			else
			{
				status = MFRC522_Request(0x52, card_pydebuf);
				if(status == 0)//寻卡，检测是否有卡放下
				{
					OLED_Clear();
					status = MFRC522_Anticoll(card_numberbuf);//防撞处理
					for(uint8_t i = 0;i<3;i++)
					{
						ID_cunchu[i] = card_numberbuf[2+i];
					}
					luoji.set_flag = 0;	//设置
					OLED_ShowString(0,16*2,"ID ",16,1);
					char str[20];
					sprintf(str,"%2d%2d%2d",ID_cunchu[0],ID_cunchu[1],ID_cunchu[2]);
					OLED_ShowString(40,16*2,(uint8_t*)str,16,1);
					delay_ms(1000);
					delay_ms(1000);
					delay_ms(1000);
					OLED_Clear();
	//				printf("开始运行");

				}
			}
```

- 首先，刷卡模块首先使用`MFRC522_Request`函数尝试检测天线区内是否存在卡片。这是通过向RFID卡发送`PICC_REQALL`指令（`0x52`），也就是寻找天线区内所有的卡来完成的。如果检测到卡片了，那么`MFRC522_Request`函数将返回成功（`MI_OK`），并且`card_pydebuf`将被赋值为卡的类型号。`status = MFRC522_Request(0x52, card_pydebuf)`这行代码即是判断是否寻找到卡片。如果status等于0，表示寻找到了卡片。在`MFRC522_Request`函数中，我们通过`Write_MFRC522`函数，设置`BitFramingReg`寄存器，用于配置传输的最后一位的位数。此处设置的是`0x07`，意味着期望的有效返回位数为7位。将`reqMode`（请求模式，此处为`0x52`，寻找天线区内所有的卡）作为第一个要发送的数据，再调用`MFRC522_ToCard`函数与卡片进行交互。`MFRC522_ToCard`是发送和接收数据的核心函数。它将`TagType`(卡片类型号)发送出去，并接收返回的卡片响应。`backBits`则用于记录接收到的数据位数。
- 一旦检测到卡片，屏幕将被清理，为显示新的信息做准备。
- 其次，执行`MFRC522_Anticoll`函数进行防撞处理，即确保同一时间只有一张卡被读取，这避免了多张卡同时处于天线区内时可能发生的数据冲突。`MFRC522_Anticoll`函数会将卡的序列号存储在`card_numberbuf`中，实现处理卡片防冲突机制。在多张RFID卡片同时存在于天线区内时，通过这种机制可以确保正确、有效地选取单一卡片进行操作。会先通过清除相关位（`Status2Reg`和`CollReg`），准备进行防冲突操作。设置`BitFramingReg`寄存器，指示不预期在最后一个字节传输额外的位。`serNum`数组的前两个字节设置为特定值（`PICC_ANTICOLL1`和`0x20`），然后调用`MFRC522_ToCard`执行防冲突指令，同时传输并接收数据。`serNum`最后将包含卡序列号和校验字节。如果函数执行成功，会进行序列号的校验，确保读取的序列号数据无误。最后设置`CollReg`的相关位，完成防冲突流程。
- 然后，从`card_numberbuf`中提取序列号的一部分（从第2位开始的三位），并存储到`ID_cunchu`数组中。这能够简化处理过程，在存储完卡号后，程序将`luoji.set_flag`设置为0，表示刷卡成功。
- 接下来，代码通过OLED显示这段存储的卡号。使用`OLED_ShowString`函数将`ID_cunchu`中的内容以及一些文本显示在屏幕上。
- 最后，程序执行了三次`delay_ms(1000)`，意味着总共延迟了3秒，能够为用户提供足够的时间来看清楚显示的信息 



==2024-4-2==

原来：指导老师查看论文三稿，并对问题进行批注和进行指导，要求下来修改完善。

改版：

在指导老师查看论文三稿后，对基于机器学习的电动汽车状态监测与可视化系统的论文改进建议去跟进，着手深入研究最近几年有关“基于机器学习的电动汽车状态监测与可视化系统”的相关论文和报告。阅读了几篇权威的期刊论文和多份研究报告，以期获取更全面的视角和更深入的理解。同时，我也通过查找找到了一些系统和机器学习算法相关的参考书籍，帮助我更好地理解这个领域的最新动态和发展，计划继续继续阅读相关文献，并将提取的信息反馈到我下一版的论文草稿中，将这些参考文献反馈到草稿中，并确保正确引用每一篇参考文献，以满足指导老师的期望。



==2024-3-31==

原来：学生与指导老师沟通交流意见，完成三稿，并上传群文件。

改版：

根据之前的反馈和建议，对论文进行了一系列的修订和完善，于今日完成论文的第三稿。然后与指导老师进行了深入的交流和探讨，着重讨论了论文的各种细节，以及如何改进以提高论文的品质。在与指导老师讨论后，即可对论文做出了一些调整，加强了论文的论证力度，优化了结构逻辑，也更正了一些标点错误。然后，我将论文的版本上传到了我们的论文群文件，以便其他组员查看和提出他们的反馈。同时，我会继续关注与我项目有关的最新研究，保持更新我在这个领域的知识，也会与同组的组员交流学习，以便能进一步提升论文的质量。





==2024-3-18==

原来：指导老师查看论文二稿，并进行问题性的批注，提出论文中仍然存在一些细节问题需要完善。

改版：

在指导老师对我的论文二稿的仔细阅读和有价值的批注后，特别注意到了指导老师关于摘要和关键词问题的注释。首先，老师指出，摘要部分应当是整篇论文的核心总结。这确实激发了我深入思考如何将背景信息、研究中的问题、解决问题的方法，以及方法的效果和优点。我已经写下了新的摘要，以回应老师的指导意见，让摘要更能体现出论文的价值所在。再次，关键词的选择也对于我的论文有重要意义。关键词是索引论文的主题词，应该是有目的性和关联性的，不能随意选择。我已经重新挑选了一组更有代表性和相关性的关键词，来准确地表达我的研究焦点。我会继续审查和修改我的论文，以应对可能出现的其他问题。同时，我也会持续集中精力研究的我的主题，以确保我对它有深入的理解。

 

` main.c`中的刷卡模块代码：

```
//通过刷卡模块检测
			else
			{
				status = MFRC522_Request(0x52, card_pydebuf);
				if(status == 0)//寻卡，检测是否有卡放下
				{
					OLED_Clear();
					status = MFRC522_Anticoll(card_numberbuf);//防撞处理
					for(uint8_t i = 0;i<3;i++)
					{
						ID_cunchu[i] = card_numberbuf[2+i];
					}
					luoji.set_flag = 0;	//设置
					OLED_ShowString(0,16*2,"ID ",16,1);
					char str[20];
					sprintf(str,"%2d%2d%2d",ID_cunchu[0],ID_cunchu[1],ID_cunchu[2]);
					OLED_ShowString(40,16*2,(uint8_t*)str,16,1);
					delay_ms(1000);
					delay_ms(1000);
					delay_ms(1000);
					OLED_Clear();
	//				printf("开始运行");

				}
			}
```

`main.c`中调用的`MFRC522_Request`函数具体内容：

```
u8 MFRC522_Request(u8 reqMode, u8 *TagType)
{  
	u8  status;    
	u16 backBits;   //接收到的数据位数
	//   
	Write_MFRC522(BitFramingReg, 0x07);  //TxLastBists = BitFramingReg[2..0]   
	TagType[0] = reqMode;  
	status = MFRC522_ToCard(PCD_TRANSCEIVE, TagType, 1, TagType, &backBits); 
	// 
	if ((status != MI_OK) || (backBits != 0x10))  
	{       
		status = MI_ERR;
	}
	//  
	return status; 
}
```

`main.c`中调用的`MFRC522_Anticoll`函数：

```
//功能描述防冲突检测读取选中卡片的卡序列号
//输入参数serNum--返回4字节卡序列号,第5字节为校验字节
//返 回 值成功返回MI_OK
u8 MFRC522_Anticoll(u8 *serNum) 
{     
	u8  status;     
	u8  i;     
	u8  serNumCheck=0;     
	u16 unLen;
	//           
	ClearBitMask(Status2Reg, 0x08);  			//TempSensclear     
	ClearBitMask(CollReg,0x80);   				//ValuesAfterColl  
	Write_MFRC522(BitFramingReg, 0x00);  	//TxLastBists = BitFramingReg[2..0]
	serNum[0] = PICC_ANTICOLL1;     
	serNum[1] = 0x20;     
	status = MFRC522_ToCard(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen);
	//      
	if (status == MI_OK)
	{   
		//校验卡序列号   
		for(i=0;i<4;i++)   
			serNumCheck^=serNum[i];
		//
		if(serNumCheck!=serNum[i])        
			status=MI_ERR;
	}
	SetBitMask(CollReg,0x80);  //ValuesAfterColl=1
	//      
	return status;
}

```

